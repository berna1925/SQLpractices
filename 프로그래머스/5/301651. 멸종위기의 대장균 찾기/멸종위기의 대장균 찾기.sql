# 2025-08-03 13:40 자력 해결
# WITH RECURSIVE, WITH 병렬 연결문, LEFT JOIN, INNER JOIN이 모두 활용된 최고난도 문제 해결
# 계층 연결을 상상하고 적절한 코드를 떠올리는 연습을 좀 더 해야 할 듯
WITH RECURSIVE GEN AS (
    SELECT ID, 1 AS GENERATION
    FROM ECOLI_DATA
    WHERE PARENT_ID IS NULL
    
    UNION ALL 
    
    SELECT C.ID, GENERATION + 1
    FROM ECOLI_DATA C
    JOIN GEN G ON C.PARENT_ID = G.ID
),
NO_CHILD AS (
    SELECT P.ID
    FROM ECOLI_DATA P LEFT JOIN ECOLI_DATA C ON P.ID = C.PARENT_ID
    # JOIN GEN ON P.ID = GEN.ID
    WHERE C.ID IS NULL
)

SELECT COUNT(N.ID) AS COUNT, GENERATION
FROM NO_CHILD N JOIN GEN ON N.ID = GEN.ID
GROUP BY GENERATION
ORDER BY GENERATION ;


#=====================================================================================================================



# WITH RECURSIVE ECOLI_HIERARCHY AS (
#     -- 1. 최초 개체(1세대) 설정
#     SELECT ID, PARENT_ID, 1 AS GENERATION
#     FROM ECOLI_DATA
#     WHERE PARENT_ID IS NULL

#     UNION ALL

#     -- 2. 부모를 따라가며 세대 증가
#     SELECT e.ID, e.PARENT_ID, h.GENERATION + 1
#     FROM ECOLI_DATA e
#     JOIN ECOLI_HIERARCHY h ON e.PARENT_ID = h.ID
# )

# -- 3. 각 세대별로 자식이 없는 개체 개수 세기
# SELECT COUNT(h.ID) AS COUNT, h.GENERATION
# FROM ECOLI_HIERARCHY h
# LEFT JOIN ECOLI_DATA e ON h.ID = e.PARENT_ID
# WHERE e.PARENT_ID IS NULL  -- 자식이 없는 개체만 선택
# GROUP BY h.GENERATION
# ORDER BY h.GENERATION;

# WITH GENERATION_TABLE AS (
#     SELECT ID, PARENT_ID, 1 AS GENERATION
#     FROM ECOLI_DATA
#     WHERE PARENT_ID IS NULL  -- 최초 개체 (1세대)

#     UNION ALL

#     SELECT e.ID, e.PARENT_ID, g.GENERATION + 1
#     FROM ECOLI_DATA e
#     JOIN GENERATION_TABLE g
#     ON e.PARENT_ID = g.ID
# )

# -- 자식이 없는(Leaf Node) 개체를 찾음
# SELECT COUNT(*) AS COUNT, GENERATION
# FROM GENERATION_TABLE g
# WHERE NOT EXISTS (
#     SELECT 1 FROM ECOLI_DATA e WHERE e.PARENT_ID = g.ID
# )  
# GROUP BY GENERATION
# ORDER BY GENERATION;






# SELECT P.ID, COUNT(C.ID) AS CT
# FROM ECOLI_DATA P LEFT JOIN ECOLI_DATA C ON P.ID = C.PARENT_ID
# WHERE C.ID IS NULL
# GROUP BY P.ID


